import { Scope } from '@nestjs/common';
import { Abstract, Controller, DynamicModule, Injectable, NestModule } from '@nestjs/common/interfaces';
import { Type } from '@nestjs/common/interfaces/type.interface';
import { NestContainer } from './container';
import { InstanceWrapper } from './instance-wrapper';
export interface CustomProvider {
    provide: any;
    name: string;
}
export declare type OpaqueToken = string | symbol | Type<any> | Function | Abstract<any>;
export declare type CustomClass = CustomProvider & {
    useClass: Type<any>;
    scope?: Scope;
};
export declare type CustomFactory = CustomProvider & {
    useFactory: (...args: any[]) => any;
    inject?: OpaqueToken[];
    scope?: Scope;
};
export declare type CustomValue = CustomProvider & {
    useValue: any;
};
export declare type ProviderMetatype = Type<Injectable> | CustomFactory | CustomValue | CustomClass;
export declare class Module {
    private readonly _metatype;
    private readonly _scope;
    private readonly container;
    private readonly _id;
    private readonly _imports;
    private readonly _providers;
    private readonly _injectables;
    private readonly _controllers;
    private readonly _exports;
    constructor(_metatype: Type<any>, _scope: Type<any>[], container: NestContainer);
    readonly id: string;
    readonly scope: Type<any>[];
    readonly providers: Map<any, InstanceWrapper<Injectable>>;
    readonly imports: Set<Module>;
    /**
     * Left for backward-compatibility reasons
     */
    readonly relatedModules: Set<Module>;
    /**
     * Left for backward-compatibility reasons
     */
    readonly components: Map<string, InstanceWrapper<Injectable>>;
    /**
     * Left for backward-compatibility reasons
     */
    readonly routes: Map<string, InstanceWrapper<Controller>>;
    readonly injectables: Map<string, InstanceWrapper<Injectable>>;
    readonly controllers: Map<string, InstanceWrapper<Controller>>;
    readonly exports: Set<string | symbol>;
    readonly instance: NestModule;
    readonly metatype: Type<any>;
    addCoreProviders(container: NestContainer): void;
    addModuleRef(): void;
    addModuleAsProvider(): void;
    addInjectable<T extends Injectable>(injectable: Type<T>, host?: Type<T>): string;
    addProvider(provider: ProviderMetatype): string;
    isCustomProvider(provider: ProviderMetatype): provider is CustomClass | CustomFactory | CustomValue;
    addCustomProvider(provider: CustomFactory | CustomValue | CustomClass, collection: Map<string, any>): string;
    isCustomClass(provider: any): provider is CustomClass;
    isCustomValue(provider: any): provider is CustomValue;
    isCustomFactory(provider: any): provider is CustomFactory;
    isDynamicModule(exported: any): exported is DynamicModule;
    addCustomClass(provider: CustomClass, collection: Map<string, InstanceWrapper>): void;
    addCustomValue(provider: CustomValue, collection: Map<string, InstanceWrapper>): void;
    addCustomFactory(provider: CustomFactory, collection: Map<string, InstanceWrapper>): void;
    addExportedProvider(provider: ProviderMetatype | string | symbol | DynamicModule): Set<string | symbol>;
    addCustomExportedProvider(provider: CustomFactory | CustomValue | CustomClass): Set<string | symbol>;
    validateExportedProvider(token: string | symbol): string | symbol;
    addController(controller: Type<Controller>): void;
    addRelatedModule(module: any): void;
    replace(toReplace: string | symbol | Type<any>, options: any): string;
    hasProvider(token: string | symbol | Type<any>): boolean;
    hasInjectable(token: string | symbol | Type<any>): boolean;
    getProviderStaticToken(provider: string | symbol | Type<any>): string | symbol;
    getProviderByKey<T = any>(name: string | symbol): InstanceWrapper<T>;
    createModuleReferenceType(): any;
    private getClassScope;
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("@nestjs/common");
const shared_utils_1 = require("@nestjs/common/utils/shared.utils");
const unknown_module_exception_1 = require("./errors/exceptions/unknown-module.exception");
const hooks_1 = require("./hooks");
const container_scanner_1 = require("./injector/container-scanner");
const module_token_factory_1 = require("./injector/module-token-factory");
class NestApplicationContext {
    constructor(container, scope = [], contextModule = null) {
        this.container = container;
        this.scope = scope;
        this.contextModule = contextModule;
        this.moduleTokenFactory = new module_token_factory_1.ModuleTokenFactory();
        this.activeShutdownSignals = new Array();
        this.containerScanner = new container_scanner_1.ContainerScanner(container);
    }
    selectContextModule() {
        const modules = this.container.getModules().values();
        this.contextModule = modules.next().value;
    }
    select(module) {
        const modules = this.container.getModules();
        const moduleMetatype = this.contextModule.metatype;
        const scope = this.scope.concat(moduleMetatype);
        const token = this.moduleTokenFactory.create(module, scope);
        const selectedModule = modules.get(token);
        if (!selectedModule) {
            throw new unknown_module_exception_1.UnknownModuleException();
        }
        return new NestApplicationContext(this.container, scope, selectedModule);
    }
    get(typeOrToken, options = { strict: false }) {
        if (!(options && options.strict)) {
            return this.find(typeOrToken);
        }
        return this.findInstanceByPrototypeOrToken(typeOrToken, this.contextModule);
    }
    async init() {
        await this.callInitHook();
        await this.callBootstrapHook();
        return this;
    }
    async close() {
        await this.callDestroyHook();
        await this.callShutdownHook();
    }
    useLogger(logger) {
        common_1.Logger.overrideLogger(logger);
    }
    /**
     * Enables the usage of shutdown hooks. Will call the
     * `onApplicationShutdown` function of a provider if the
     * process receives a shutdown signal.
     *
     * @param {ShutdownSignal[]} [signals=[]] The system signals it should listen to
     *
     * @returns {this} The Nest application context instance
     */
    enableShutdownHooks(signals = []) {
        if (shared_utils_1.isEmpty(signals)) {
            signals = Object.keys(common_1.ShutdownSignal).map((key) => common_1.ShutdownSignal[key]);
        }
        else {
            // given signals array should be unique because
            // process shouldn't listen to the same signal more than once.
            signals = Array.from(new Set(signals));
        }
        signals = signals
            .map((signal) => signal
            .toString()
            .toUpperCase()
            .trim())
            // filter out the signals which is already listening to
            .filter(signal => !this.activeShutdownSignals.includes(signal));
        this.listenToShutdownSignals(signals);
        return this;
    }
    /**
     * Listens to shutdown signals by listening to
     * process events
     *
     * @param {string[]} signals The system signals it should listen to
     */
    listenToShutdownSignals(signals) {
        signals.forEach((signal) => {
            this.activeShutdownSignals.push(signal);
            process.on(signal, async (code) => {
                // Call the destroy and shutdown hook
                // in case the process receives a shutdown signal
                await this.callDestroyHook();
                await this.callShutdownHook(signal);
                process.exit(code || 1);
            });
        });
    }
    /**
     * Calls the `onModuleInit` function on the registered
     * modules and its children.
     */
    async callInitHook() {
        const modulesContainer = this.container.getModules();
        for (const module of [...modulesContainer.values()].reverse()) {
            await hooks_1.callModuleInitHook(module);
        }
    }
    /**
     * Calls the `onModuleDestroy` function on the registered
     * modules and its children.
     */
    async callDestroyHook() {
        const modulesContainer = this.container.getModules();
        for (const module of modulesContainer.values()) {
            await hooks_1.callModuleDestroyHook(module);
        }
    }
    /**
     * Calls the `onApplicationBootstrap` function on the registered
     * modules and its children.
     */
    async callBootstrapHook() {
        const modulesContainer = this.container.getModules();
        for (const module of [...modulesContainer.values()].reverse()) {
            await hooks_1.callModuleBootstrapHook(module);
        }
    }
    /**
     * Calls the `onApplicationShutdown` function on the registered
     * modules and children.
     */
    async callShutdownHook(signal) {
        const modulesContainer = this.container.getModules();
        for (const module of [...modulesContainer.values()].reverse()) {
            await hooks_1.callAppShutdownHook(module, signal);
        }
    }
    find(typeOrToken) {
        return this.containerScanner.find(typeOrToken);
    }
    findInstanceByPrototypeOrToken(metatypeOrToken, contextModule) {
        return this.containerScanner.findInstanceByPrototypeOrToken(metatypeOrToken, contextModule);
    }
}
exports.NestApplicationContext = NestApplicationContext;

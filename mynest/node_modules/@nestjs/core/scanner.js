"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("@nestjs/common/constants");
const random_string_generator_util_1 = require("@nestjs/common/utils/random-string-generator.util");
const shared_utils_1 = require("@nestjs/common/utils/shared.utils");
const application_config_1 = require("./application-config");
const constants_2 = require("./constants");
const circular_dependency_exception_1 = require("./errors/exceptions/circular-dependency.exception");
class DependenciesScanner {
    constructor(container, metadataScanner, applicationConfig = new application_config_1.ApplicationConfig()) {
        this.container = container;
        this.metadataScanner = metadataScanner;
        this.applicationConfig = applicationConfig;
        this.applicationProvidersApplyMap = [];
    }
    async scan(module) {
        await this.registerCoreModule();
        await this.scanForModules(module);
        await this.scanModulesForDependencies();
        this.container.bindGlobalScope();
    }
    async scanForModules(module, scope = [], ctxRegistry = []) {
        const moduleInstance = await this.insertModule(module, scope);
        ctxRegistry.push(module);
        if (this.isForwardReference(module)) {
            module = module.forwardRef();
        }
        const modules = !this.isDynamicModule(module)
            ? this.reflectMetadata(module, constants_1.METADATA.IMPORTS)
            : [
                ...this.reflectMetadata(module.module, constants_1.METADATA.IMPORTS),
                ...(module.imports || []),
            ];
        for (const innerModule of modules) {
            if (ctxRegistry.includes(innerModule)) {
                continue;
            }
            await this.scanForModules(innerModule, [].concat(scope, module), ctxRegistry);
        }
        return moduleInstance;
    }
    async insertModule(module, scope) {
        if (module && module.forwardRef) {
            return this.container.addModule(module.forwardRef(), scope);
        }
        return this.container.addModule(module, scope);
    }
    async scanModulesForDependencies() {
        const modules = this.container.getModules();
        for (const [token, { metatype }] of modules) {
            await this.reflectImports(metatype, token, metatype.name);
            this.reflectProviders(metatype, token);
            this.reflectControllers(metatype, token);
            this.reflectExports(metatype, token);
        }
    }
    async reflectImports(module, token, context) {
        const modules = [
            ...this.reflectMetadata(module, constants_1.METADATA.IMPORTS),
            ...this.container.getDynamicMetadataByToken(token, constants_1.METADATA.IMPORTS),
        ];
        for (const related of modules) {
            await this.insertImport(related, token, context);
        }
    }
    reflectProviders(module, token) {
        const providers = [
            ...this.reflectMetadata(module, constants_1.METADATA.PROVIDERS),
            ...this.container.getDynamicMetadataByToken(token, constants_1.METADATA.PROVIDERS),
        ];
        providers.forEach(provider => {
            this.insertProvider(provider, token);
            this.reflectDynamicMetadata(provider, token);
        });
    }
    reflectControllers(module, token) {
        const controllers = [
            ...this.reflectMetadata(module, constants_1.METADATA.CONTROLLERS),
            ...this.container.getDynamicMetadataByToken(token, constants_1.METADATA.CONTROLLERS),
        ];
        controllers.forEach(item => {
            this.insertController(item, token);
            this.reflectDynamicMetadata(item, token);
        });
    }
    reflectDynamicMetadata(obj, token) {
        if (!obj || !obj.prototype) {
            return;
        }
        this.reflectInjectables(obj, token, constants_1.GUARDS_METADATA);
        this.reflectInjectables(obj, token, constants_1.INTERCEPTORS_METADATA);
        this.reflectInjectables(obj, token, constants_1.EXCEPTION_FILTERS_METADATA);
        this.reflectInjectables(obj, token, constants_1.PIPES_METADATA);
        this.reflectParamInjectables(obj, token, constants_1.ROUTE_ARGS_METADATA);
    }
    reflectExports(module, token) {
        const exports = [
            ...this.reflectMetadata(module, constants_1.METADATA.EXPORTS),
            ...this.container.getDynamicMetadataByToken(token, constants_1.METADATA.EXPORTS),
        ];
        exports.forEach(exportedProvider => this.insertExportedProvider(exportedProvider, token));
    }
    reflectInjectables(component, token, metadataKey) {
        const controllerInjectables = this.reflectMetadata(component, metadataKey);
        const methodsInjectables = this.metadataScanner.scanFromPrototype(null, component.prototype, this.reflectKeyMetadata.bind(this, component, metadataKey));
        const flattenMethodsInjectables = methodsInjectables.reduce((a, b) => a.concat(b), []);
        const injectables = [
            ...controllerInjectables,
            ...flattenMethodsInjectables,
        ].filter(shared_utils_1.isFunction);
        injectables.forEach(injectable => this.insertInjectable(injectable, token, component));
    }
    reflectParamInjectables(component, token, metadataKey) {
        const paramsMetadata = this.metadataScanner.scanFromPrototype(null, component.prototype, method => Reflect.getMetadata(metadataKey, component, method));
        const flatten = (arr) => arr.reduce((a, b) => a.concat(b), []);
        const paramsInjectables = flatten(paramsMetadata).map((param) => flatten(Object.keys(param).map(k => param[k].pipes)).filter(shared_utils_1.isFunction));
        flatten(paramsInjectables).forEach((injectable) => this.insertInjectable(injectable, token, component));
    }
    reflectKeyMetadata(component, key, method) {
        let prototype = component.prototype;
        do {
            const descriptor = Reflect.getOwnPropertyDescriptor(prototype, method);
            if (!descriptor) {
                continue;
            }
            return Reflect.getMetadata(key, descriptor.value);
        } while (
        // tslint:disable-next-line:no-conditional-assignment
        (prototype = Reflect.getPrototypeOf(prototype)) &&
            prototype !== Object.prototype &&
            prototype);
        return undefined;
    }
    async insertImport(related, token, context) {
        if (shared_utils_1.isUndefined(related)) {
            throw new circular_dependency_exception_1.CircularDependencyException(context);
        }
        if (related && related.forwardRef) {
            return this.container.addImport(related.forwardRef(), token);
        }
        await this.container.addImport(related, token);
    }
    isCustomProvider(provider) {
        return provider && !shared_utils_1.isNil(provider.provide);
    }
    insertProvider(provider, token) {
        const isCustomProvider = this.isCustomProvider(provider);
        if (!isCustomProvider) {
            return this.container.addProvider(provider, token);
        }
        const applyProvidersMap = this.getApplyProvidersMap();
        const providersKeys = Object.keys(applyProvidersMap);
        const type = provider
            .provide;
        if (!providersKeys.includes(type)) {
            return this.container.addProvider(provider, token);
        }
        const providerToken = random_string_generator_util_1.randomStringGenerator();
        this.applicationProvidersApplyMap.push({
            type,
            moduleKey: token,
            providerKey: providerToken,
        });
        this.container.addProvider(Object.assign({}, provider, { provide: providerToken }), token);
    }
    insertInjectable(injectable, token, host) {
        this.container.addInjectable(injectable, token, host);
    }
    insertExportedProvider(exportedProvider, token) {
        this.container.addExportedProvider(exportedProvider, token);
    }
    insertController(controller, token) {
        this.container.addController(controller, token);
    }
    reflectMetadata(metatype, metadataKey) {
        return Reflect.getMetadata(metadataKey, metatype) || [];
    }
    async registerCoreModule() {
        const module = this.container.createCoreModule();
        const instance = await this.scanForModules(module);
        this.container.registerCoreModuleRef(instance);
    }
    applyApplicationProviders() {
        const applyProvidersMap = this.getApplyProvidersMap();
        this.applicationProvidersApplyMap.forEach(({ moduleKey, providerKey, type }) => {
            const modules = this.container.getModules();
            const { providers } = modules.get(moduleKey);
            const { instance } = providers.get(providerKey);
            applyProvidersMap[type](instance);
        });
    }
    getApplyProvidersMap() {
        return {
            [constants_2.APP_INTERCEPTOR]: (interceptor) => this.applicationConfig.addGlobalInterceptor(interceptor),
            [constants_2.APP_PIPE]: (pipe) => this.applicationConfig.addGlobalPipe(pipe),
            [constants_2.APP_GUARD]: (guard) => this.applicationConfig.addGlobalGuard(guard),
            [constants_2.APP_FILTER]: (filter) => this.applicationConfig.addGlobalFilter(filter),
        };
    }
    isDynamicModule(module) {
        return module && !!module.module;
    }
    isForwardReference(module) {
        return module && !!module.forwardRef;
    }
}
exports.DependenciesScanner = DependenciesScanner;
